#include "/Users/tommasoviscido/Downloads/Progetto_PCS_2024/Project/fracture.hpp"
#include <fstream>
#include <sstream>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <Eigen/Eigen>

using namespace std;
using namespace Eigen;

// Function to read fractures from a file
vector<Fracture> readFractures(const string& filename) {
    ifstream file(filename);
    if (!file.is_open()) {
        cerr << "Unable to open file: " << filename << endl;
        return {};
    }

    vector<Fracture> fractures;
    string line;

    getline(file, line);

    getline(file, line);
    int numFractures;
    istringstream(line) >> numFractures;
    fractures.reserve(numFractures);

    for (int i = 0; i < numFractures; i++) {
        Fracture f;

        getline(file, line);

        getline(file, line);
        istringstream issFracture(line);
        string block;

        getline(issFracture, block, ';');
        istringstream(block) >> f.id;

        getline(issFracture, block);
        istringstream(block) >> f.numVertices;

        getline(file, line);

        f.vertices.resize(f.numVertices);
        for (int j = 0; j < 3; j++) {
            getline(file, line);
            istringstream issVertex(line);
            for (int k = 0; k < f.numVertices; k++) {
                getline(issVertex, block, ';');
                if (j == 0) {
                    istringstream(block) >> f.vertices[k].x;
                } else if (j == 1) {
                    istringstream(block) >> f.vertices[k].y;
                } else {
                    istringstream(block) >> f.vertices[k].z;
                }
            }
        }
        fractures.push_back(f);
    }

    return fractures;
}

double calculateDistance(const Vertex& v1, const Vertex& v2) {
    return sqrt(pow(v1.x - v2.x, 2) + pow(v1.y - v2.y, 2) + pow(v1.z - v2.z, 2));
}

Vertex crossProduct(const Vertex& v1, const Vertex& v2) {
    return {
        v1.y * v2.z - v1.z * v2.y,
        v1.z * v2.x - v1.x * v2.z,
        v1.x * v2.y - v1.y * v2.x
    };
}

double dotProduct(const Vertex& v1, const Vertex& v2) {
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
}

Vertex subtract(const Vertex& v1, const Vertex& v2) {
    return { v1.x - v2.x, v1.y - v2.y, v1.z - v2.z };
}

// Function to project a fracture on a given axis
Projection projectFractureOnAxis(const Fracture& fracture, const Vertex& axis) {
    double min = dotProduct(axis, fracture.vertices[0]);
    double max = min;

    for (int i = 1; i < fracture.numVertices; i++) {
        double projection = dotProduct(axis, fracture.vertices[i]);
        if (projection < min) min = projection;
        if (projection > max) max = projection;
    }

    return { min, max };
}

// Function to check if two fractures intersect
bool fractureIntersection(const Fracture& f1, const Fracture& f2) {
    vector<Vertex> axes;

    for (int i = 0; i < f1.numVertices; i++) {
        Vertex edge1 = subtract(f1.vertices[(i + 1) % f1.numVertices], f1.vertices[i]);
        for (int j = 0; j < f2.numVertices; j++) {
            Vertex edge2 = subtract(f2.vertices[(j + 1) % f2.numVertices], f2.vertices[j]);
            axes.push_back(crossProduct(edge1, edge2));
        }
    }

    for (const auto& axis : axes) {
        Projection p1 = projectFractureOnAxis(f1, axis);
        Projection p2 = projectFractureOnAxis(f2, axis);
        if (p1.max < p2.min || p2.max < p1.min) {
            return false;
        }
    }

    return true;
}

// Function to calculate the plane generated by a fracture
Plane calculatePlane(const Fracture& fracture) {
    Vertex v1 = fracture.vertices[0];
    Vertex v2 = fracture.vertices[1];
    Vertex v3 = fracture.vertices[2];

    Vertex normal = crossProduct(subtract(v2, v1), subtract(v3, v1));
    double d = dotProduct(normal, v1);

    return { normal, d };
}

// Function to find the intersection line between two planes
vector<Vertex> findIntersectionLine(const Plane& p1, const Plane& p2) {
    Vertex direction = crossProduct(p1.normal, p2.normal);

    Matrix3d A;
    A << p1.normal.x, p1.normal.y, p1.normal.z,
        p2.normal.x, p2.normal.y, p2.normal.z,
        direction.x, direction.y, direction.z;

    Vector3d b(p1.d, p2.d, 0);

    Vector3d result = A.colPivHouseholderQr().solve(b);

    Vertex point{result(0), result(1), result(2)};

    return { point, direction };
}

// Function to find the intersection of a line with an edge
Vertex lineEdgeIntersection(const Vertex& point, const Vertex& direction, const Vertex& v1, const Vertex& v2) {
    Vector3d p0(point.x, point.y, point.z);
    Vector3d d(direction.x, direction.y, direction.z);
    Vector3d v10(v1.x, v1.y, v1.z);
    Vector3d v20(v2.x, v2.y, v2.z);

    Vector3d edge = v20 - v10;
    Vector3d p0v10 = v10 - p0;

    Matrix3d A;
    A.col(0) = d;
    A.col(1) = -edge;
    A.col(2) = edge.cross(d);

    double detA = A.determinant();
    if (abs(detA) < 1e-6) {
        return { NAN, NAN, NAN };
    }

    Vector3d b = p0v10;
    Vector3d t = A.colPivHouseholderQr().solve(b);

    Vector3d intersection = p0 + t(0) * d;

    double t_intersection = t(1);
    if (t_intersection >= 0 && t_intersection <= 1) {
        return { intersection(0), intersection(1), intersection(2) };
    } else {
        return { NAN, NAN, NAN };
    }
}

// Function to compute the parameter t for a given point and direction
double compute_t(const Vertex& v, const Vertex& point, const Vertex& direction) {
    return (v.x - point.x) / direction.x;
}

// Function to compare pairs of doubles and vertices based on the double value
bool comparePairs(const pair<double, Vertex>& a, const pair<double, Vertex>& b) {
    return a.first < b.first;
}

// Function to check if a point is on an edge
bool isPointOnEdge(const Vertex& p, const Vertex& v1, const Vertex& v2) {
    double epsilon = 1e-6;
    double d1 = sqrt(pow(p.x - v1.x, 2) + pow(p.y - v1.y, 2) + pow(p.z - v1.z, 2));
    double d2 = sqrt(pow(p.x - v2.x, 2) + pow(p.y - v2.y, 2) + pow(p.z - v2.z, 2));
    double d3 = sqrt(pow(v1.x - v2.x, 2) + pow(v1.y - v2.y, 2) + pow(v1.z - v2.z, 2));
    return fabs(d1 + d2 - d3) < epsilon;
}

// Function to check if a line segment passes through a fracture
bool isPassante(const Vertex& p1, const Vertex& p2, const Fracture& fracture) {
    bool onEdge1 = false, onEdge2 = false;
    const auto& vertices = fracture.vertices;
    for (size_t i = 0; i < vertices.size(); i++) {
        Vertex v1 = vertices[i];
        Vertex v2 = vertices[(i + 1) % vertices.size()];
        if (isPointOnEdge(p1, v1, v2)) onEdge1 = true;
        if (isPointOnEdge(p2, v1, v2)) onEdge2 = true;
    }
    return onEdge1 && onEdge2;
}

// Function to find the middle points out of four of an intersection line
vector<Vertex> getMiddlePoints(const Vertex& point, const Vertex& direction, const Vertex& v1, const Vertex& v2, const Vertex& v3, const Vertex& v4) {
    vector<pair<double, Vertex>> points = {
        {compute_t(v1, point, direction), v1},
        {compute_t(v2, point, direction), v2},
        {compute_t(v3, point, direction), v3},
        {compute_t(v4, point, direction), v4}
    };

    sort(points.begin(), points.end(), comparePairs);

    vector<Vertex> result = {points[1].second, points[2].second};
    return result;
}

// Function to compute all the traces of the DFN
vector<Trace> computeTraces(const vector<Fracture> &fractures) {
    vector<Trace> traces;
    int traceCounter = 0;

    for (size_t i = 0; i < fractures.size(); i++) {
        for (size_t j = i + 1; j < fractures.size(); j++) {
            if (fractureIntersection(fractures[i], fractures[j])) {
                Plane p1 = calculatePlane(fractures[i]);
                Plane p2 = calculatePlane(fractures[j]);
                vector<Vertex> line = findIntersectionLine(p1, p2);

                vector<Vertex> intersectionPoints;

                const auto& vertices1 = fractures[i].vertices;
                const auto& vertices2 = fractures[j].vertices;

                for (size_t k = 0; k < vertices1.size(); k++) {
                    Vertex v1 = vertices1[k];
                    Vertex v2 = vertices1[(k + 1) % vertices1.size()];
                    Vertex intersection = lineEdgeIntersection(line[0], line[1], v1, v2);
                    if (!isnan(intersection.x) && !isnan(intersection.y) && !isnan(intersection.z)) {
                        intersectionPoints.push_back(intersection);
                    }
                }

                for (size_t k = 0; k < vertices2.size(); k++) {
                    Vertex v1 = vertices2[k];
                    Vertex v2 = vertices2[(k + 1) % vertices2.size()];
                    Vertex intersection = lineEdgeIntersection(line[0], line[1], v1, v2);
                    if (!isnan(intersection.x) && !isnan(intersection.y) && !isnan(intersection.z)) {
                        intersectionPoints.push_back(intersection);
                    }
                }

                if (intersectionPoints.size() == 4) {
                    vector<Vertex> middlePoints = getMiddlePoints(line[0], line[1],
                                                                  intersectionPoints[0], intersectionPoints[1],
                                                                  intersectionPoints[2], intersectionPoints[3]);
                    double length = calculateDistance(middlePoints[0], middlePoints[1]);
                    bool tips1 = !isPassante(middlePoints[0], middlePoints[1], fractures[i]);
                    bool tips2 = !isPassante(middlePoints[0], middlePoints[1], fractures[j]);
                    Trace trace = {traceCounter++, fractures[i].id, fractures[j].id, middlePoints[0], middlePoints[1], tips1, tips2, length};
                    traces.push_back(trace);
                } else {
                    cout << "Fractures " << fractures[i].id << " and " << fractures[j].id << " have only one point in common" << endl;
                }
            }
        }
    }
    return traces;
}

// Function to write traces on an output file
void writeTraces(const vector<Trace>& traces, const string& filename) {
    ofstream outFile(filename);

    if (!outFile) {
        cerr << "Error opening file for writing: " << filename << endl;
        return;
    }

    outFile << "# Number of Traces" << endl;
    outFile << traces.size() << endl;

    outFile << "# TraceId; FractureId1; FractureId2; X1; Y1; Z1; X2; Y2; Z2" << endl;

    for (const auto& trace : traces) {
        outFile << trace.traceId << "; "
                << trace.fractureId1 << "; "
                << trace.fractureId2 << "; "
                << trace.start.x << "; " << trace.start.y << "; " << trace.start.z << "; "
                << trace.end.x << "; " << trace.end.y << "; " << trace.end.z << endl;
    }

    outFile.close();
}

// Algorithm to sort the traces
void merge(vector<Trace>& v, const unsigned int& sx, const unsigned int& cx, const unsigned int& dx) {
    unsigned int i = sx;
    unsigned int j = cx + 1;

    vector<Trace> b;
    b.reserve(dx - sx + 1);

    while (i <= cx && j <= dx) {
        if (v[i].length > v[j].length)
            b.push_back(v[i++]);
        else
            b.push_back(v[j++]);
    }

    if (i <= cx)
        b.insert(b.end(), v.begin() + i, v.begin() + cx + 1);
    if (j <= dx)
        b.insert(b.end(), v.begin() + j, v.begin() + dx + 1);

    copy(b.begin(), b.end(), v.begin() + sx);
}

void mergeSort(vector<Trace>& v, const unsigned int& sx, const unsigned int& dx) {
    if (sx < dx) {
        unsigned int cx = (sx + dx) / 2;
        mergeSort(v, sx, cx);
        mergeSort(v, cx + 1, dx);

        merge(v, sx, cx, dx);
    }
}

void mergeSort(vector<Trace>& v) {
    if (!v.empty()) {
        mergeSort(v, 0, v.size() - 1);
    }
}

// Function to sort all the traces and to write them on a file
void classifyAndWriteTracesByFracture(const vector<Fracture>& fractures, const vector<Trace>& traces, const string& filename) {
    ofstream outFile(filename);

    if (!outFile) {
        cerr << "Error opening file for writing." << endl;
        return;
    }

    for (const auto& fracture : fractures) {
        vector<Trace> passanti, nonPassanti;
        for (const auto& trace : traces) {
            if (trace.fractureId1 == fracture.id) {
                if (trace.tips1) {
                    nonPassanti.push_back(trace);
                } else {
                    passanti.push_back(trace);
                }
            } else if (trace.fractureId2 == fracture.id) {
                if (trace.tips2) {
                    nonPassanti.push_back(trace);
                } else {
                    passanti.push_back(trace);
                }
            }
        }

        mergeSort(passanti);
        mergeSort(nonPassanti);

        outFile << "# FractureId; NumTraces\n";
        outFile << fracture.id << "; " << (passanti.size() + nonPassanti.size()) << endl;

        outFile << "# TraceId; Tips; Length\n";
        for (const auto& trace : passanti) {
            outFile << trace.traceId << "; 0; " << trace.length << endl;
        }
        for (const auto& trace : nonPassanti) {
            outFile << trace.traceId << "; 1; " << trace.length << endl;
        }
    }
}
